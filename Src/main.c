/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/*
	I2C pin
	SCL -> B6
	SDA -> B7
	Config as alternate function open-drain
 */

#include <date_time.h>
#include <stdint.h>
#include "stm32f103xx.h"
#include "rtc.h"
#include "backup.h"
#include "encoder.h"
#include "nvic.h"
#include "interrupts.h"
#include "gpio.h"
#include "i2c.h"
#include "lcd.h"
#include "systemtick.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif



BKP_RegDef_t* bkp = BKP;
RTC_RegDef_t* rtc = RTC;
Encoder_Config_t encoder;
Interrupts_Config_t interupt;
GPIO_Handle_t gpio;
I2C_Handle_t i2c;
Date date;

uint8_t hour = 0;
uint8_t minute = 0;
uint32_t seconds = 0;

uint8_t day = 0;
uint8_t month = 0;
uint16_t year = 0;

uint8_t updateSec = 0;
uint8_t updateMinute = 0;
uint8_t updateHour = 0;
volatile uint8_t timer_ovf = 0;

uint32_t pressCount = 0;
uint8_t buttonState = 0;
volatile uint16_t encoderCount = 0;
volatile uint8_t secFlag = 0;
volatile uint8_t buttonPressed = 0;
uint32_t startTime = 0;
uint32_t endTime = 0;
uint32_t duration = 0;
uint32_t pressDuration = 0;
typedef enum{
	HOME,
	SETTING,
}State;
void buttonInteruptHandlling(void);
void (*buttonInteruptPtrFunc)(void) = 0;
void timerInit(TIMER_RegDef_t* timerX);
void startTimer(TIMER_RegDef_t* timerX);
void stopTimer(TIMER_RegDef_t* timerX);
State programState = HOME;
int main(void)
{
//	timer = TIM3;


	timerInit(TIM3);
	buttonInteruptPtrFunc = buttonInteruptHandlling;

	i2c.pI2CConfig.I2C_FMDutyCycle = I2C_FM_DUTY_2;
	i2c.pI2CConfig.I2C_SCLSpeed = I2C_SCL_SPEED_SM;
	i2c.pI2Cx = I2C1;

	gpio.GPIO_PinConfig.pinMode = INPUT_PUPD;
	gpio.GPIO_PinConfig.pinNumber = 2;
	gpio.pGPIOX = GPIOA;

	encoder.channelToCount = COUNT_ON_BOTH;
	encoder.inputPolarity = INVERTED;
	encoder.maxValue = 240;
	encoder.timerX = TIM2;

	interupt.edgeTrigger = RISING_FALLING;
	interupt.interruptPinNumber = 2;
	interupt.interruptPort = PORTA;
	interupt.priority = 15;
	date.unixTime = 1751811294;

	I2C_ClockControl(i2c.pI2Cx, ENABLE);

	GPIO_ClockControl(gpio.pGPIOX, ENABLE);
	GPIO_Init(&gpio);
	Interrupt_Config(&interupt);
	EncoderInit(&encoder);
	rtcInit(rtc);
	I2C_Init(&i2c);
	SystemTickInit();
//	bmp180GetCalibData(&i2c);


	LCD_Init(&i2c);
	enableBackupReg(bkp);
	bkpWrite16(bkp, hour, 0);
	bkpWrite16(bkp, minute, 1);
	bkpWrite16(bkp, seconds, 2);
	rtcSetSeconds(rtc, date.unixTime);
	nvicEnable(3);


	while(1){
		if(secFlag){
			date.unixTime = rtcGetSeconds(rtc);

			getDate(&date);
			getTime(&date);

			LCD_setCuror(&i2c, 0, 0);
			LCD_SendData(&i2c,'0'+date.hour/10);
			LCD_SendData(&i2c,'0'+date.hour%10);
			LCD_SendData(&i2c,':');
			LCD_SendData(&i2c,'0'+date.minute/10);
			LCD_SendData(&i2c,'0'+date.minute%10);
			LCD_SendData(&i2c,':');
			LCD_SendData(&i2c,'0'+date.seconds/10);
			LCD_SendData(&i2c,'0'+date.seconds%10);
			LCD_setCuror(&i2c, 0, 1);
			LCD_SendData(&i2c,'0'+date.day/10);
			LCD_SendData(&i2c,'0'+date.day%10);
			LCD_SendData(&i2c,'/');
			LCD_SendData(&i2c,'0'+date.month/10);
			LCD_SendData(&i2c,'0'+date.month%10);
			LCD_SendData(&i2c,'/');
			LCD_SendData(&i2c,'0'+(date.year/1000)%10);
			LCD_SendData(&i2c,'0'+(date.year/100)%10);
			LCD_SendData(&i2c,'0'+(date.year/10)%10);
			LCD_SendData(&i2c,'0'+date.year%10);
			secFlag=0;
		}

		if(timer_ovf){
			if(programState == HOME){
				programState = SETTING;
				timer_ovf = 0;
			}else{
				programState = HOME;
				timer_ovf = 0;
			}
		}

		if(programState==HOME){
			; // do some thing
		}
		else if(programState==SETTING){
			; // do some thing
		}
	}
}

void timerInit(TIMER_RegDef_t* timerX){
	TIM3_PCLK_EN();
	timerX->DIER |= (1<<0);
	timerX->PSC = 799;
	timerX->ARR = 19999;
	timerX->CNT = 0;
	timerX->CR1 |= (1<<2);
	timerX->EGR |= (1<<0);
	timerX->SR &= ~(1<<0);
	nvicEnable(29);
}

void startTimer(TIMER_RegDef_t* timerX){
    timerX->CR1 |= (1 << 0);   // Báº­t Timer
}

void stopTimer(TIMER_RegDef_t* timerX){
	timerX->CR1 &= ~(1<<0);
}

void buttonInteruptHandlling(void){
	buttonState = GPIO_ReadFromInputPin(GPIOA, 2);
	if(!buttonState){
		startTimer(TIM3);
	}else{
		stopTimer(TIM3);
	}
	buttonPressed=1;
}

RTC_IRQHandler(void){
	if(rtc->CRL&(1<<0)){
		rtc->CRL &= ~(1<<0);
		secFlag = 1;
	}
	return 0;
}

EXTI2_IRQHandler(void){
	Interrupts_Handling(&interupt,buttonInteruptPtrFunc);
}

TIM3_IRQHandler(void){
	if(TIM3->SR | (1<<0)){
		stopTimer(TIM3);
		TIM3->SR &= ~(1<<0);
		timer_ovf = 1;
	}

}
